#version 460

layout(local_size_x = 32, local_size_y = 32) in;

#include "particles3_comp_base.h"

// positions, mass in w-coordinate
layout(std430, binding=1) readonly buffer PosBuffer {
    vec4 Position[];
};

layout(std430, binding=2) buffer CellsBuffer {
    int cell_data[];
};

int npoints = 0;
uint par_size = nn*cell_size;
uint max_per_cell = par_size-1;

shared int heads[64][64];

void flush(int j, int cell_id) {
    int index = atomicAdd(heads[cell_id/nn][cell_id%nn], npoints);
    for (int i = 0; i < npoints && index+i < max_per_cell; i++) {
        cell_data[cell_id*par_size+index+i+1] = j+i;
    }
    npoints = 0;
}

void main() {
    uint threads = xsize*ysize*zsize;
    uint work_size = (particles + threads - 1) / threads;
    uint from = globalIndex * work_size;
    uint to = min(particles, from+work_size);
    int kk = nn/32;
    for (int y = 0; y < kk; y++) {
        for (int x = 0; x < kk; x++) {
            uint i = gl_LocalInvocationID.y;
            uint k = gl_LocalInvocationID.x;
            heads[kk*i+y][kk*k+x] = 0;
        }
    }
    barrier();

    int prev_cell_id = -1;
    int start_index = int(from);

    for (uint i = from; i < to; i++) {
        vec2 x = vec2(Position[i])-vec2(origin);
        ivec2 cell_index = clamp(ivec2(floor(x/h)), 0, nn-1);
        int cell_id = cell_index.y*nn+cell_index.x;
        if (prev_cell_id != -1 && cell_id != prev_cell_id) {
            flush(start_index, prev_cell_id);
            start_index = int(i);
        }
        npoints ++;
        prev_cell_id = cell_id;
    }
    if (npoints > 0) {
        flush(start_index, prev_cell_id);
    }
    barrier();

    for (int y = 0; y < kk; y++) {
        for (int x = 0; x < kk; x++) {
            uint i = gl_LocalInvocationID.y;
            uint k = gl_LocalInvocationID.x;
            ivec2 cell_index = ivec2(kk*k+x, kk*i+y);
            int cell_id = cell_index.y*nn+cell_index.x;
            cell_data[cell_id*par_size] = heads[cell_index.y][cell_index.x];
        }
    }
}
