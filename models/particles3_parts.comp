#version 460

layout(local_size_x = 32, local_size_y = 32) in;

#include "particles3_comp_base.h"

// positions, mass in w-coordinate
layout(std430, binding=1) readonly buffer PosBuffer {
    vec4 Position[];
};

layout(std430, binding=2) buffer CellsBuffer {
    int cell_data[];
};

int npoints = 0;
uint max_per_cell = cell_size-1;

void flush(int j, int cell_id) {
    int index = atomicAdd(cell_data[cell_id*cell_size], npoints);
    for (int i = 0; i < npoints && index+i < max_per_cell; i++) {
        cell_data[cell_id*cell_size+index+i+1] = j+i;
    }
    npoints = 0;
}

void main() {
    uint threads = xsize*ysize*zsize;
    uint work_size = (particles + threads - 1) / threads;
    uint from = globalIndex * work_size;
    uint to = min(particles, from+work_size);
    int kk = nn/32;
    for (int y = 0; y < kk; y++) {
        for (int x = 0; x < kk; x++) {
            uint i = gl_LocalInvocationID.y;
            uint k = gl_LocalInvocationID.x;
            for (int j = 0; j < nn; j++) {
                cell_data[(off(y*32+i,x*32+k,j))*cell_size] = 0;
            }
        }
    }
    barrier();

    int prev_cell_id = -1;
    int start_index = int(from);

    for (uint i = from; i < to; i++) {
        vec3 x = vec3(Position[i])-vec3(origin);
        ivec3 cell_index = clamp(ivec3(floor(x/h)), 0, nn-1);
        int cell_id = off(cell_index.z,cell_index.y,cell_index.x);
        if (prev_cell_id != -1 && cell_id != prev_cell_id) {
            flush(start_index, prev_cell_id);
            start_index = int(i);
        }
        npoints ++;
        //int index = atomicAdd(cell_data[cell_id*cell_size], 1);
        //if (index < max_per_cell) {
        //    cell_data[cell_id*cell_size+index+1] = int(i);
        //}
        prev_cell_id = cell_id;
    }
    if (npoints > 0) {
        flush(start_index, prev_cell_id);
    }
}
