#version 430

layout(local_size_x = 1024, local_size_y = 1024) in;

layout(std140, binding=0) uniform Settings {
    int nn;  // nx=ny=nz=nn
    int n;   // log(nn)
    int Out; // fft output
    int In;  // fft input
    int Cos; // cos table for fft
    int Sin; // sin table for fft
    float h;
    float l;
};

int sz = 2*nn;
// max grid size 1024x1024x1024
const int rs = 1024;

// density + psi + sin/cos tables
layout(std430, binding=1) buffer DensityBuffer {
    float A[];
};

// field (w-component unused)
layout(std430, binding=2) buffer EBuffer {
    vec4 E[];
};

/*
struct Body {
    vec3 x;
    vec3 v;
    vec3 a;
    vec3 aprev;
    float mass;
    int enabled;
    ivec3 cellid;
};

struct Cell {
    int first_body;
    int nbodies;
};
*/

/*
layout(std430, binding=1) buffer BodiesBuffer {
    Body Bodies[];
};

layout(std430, binding=2) buffer CellsBuffer {
    Cell Cells[];
};

layout(std430, binding=3) buffer NodesBuffer {
    int Nodes[];
};
*/

void padvance(inout float a[rs], int idx)
{
    for (int j = 0; j <= idx - 1; j++) {
        float a1 = a[j] + a[idx + j];
        float a2 = a[j] - a[idx + j];
        a[j]       = a1;
        a[idx + j] = a2;
    }
}

void sadvance(int ioff, int idx) {
    for (int j = 1; j <= idx - 1; j ++) {
        float a1 = A[ioff+j] - A[ioff+2 * idx - j];
        float a2 = A[ioff+j] + A[ioff+2 * idx - j];
        A[ioff+j]           = a1;
        A[ioff+2 * idx - j] = a2;
    }
}

void cadvance(int ioff, int idx) {
    for (int j = 0; j <= idx - 1; j ++) {
        float a1 = A[ioff+j] + A[ioff+2 * idx - j];
        float a2 = A[ioff+j] - A[ioff+2 * idx - j];
        A[ioff+j]           = a1;
        A[ioff+2 * idx - j] = a2;
    }
}

// fft s->S
void pFFT_1(inout float S[rs], inout float a[rs], float dx, int N, int n) {
    int N_2 = N/2;
    int yoff = 0; // [0..N/2]
    int _yoff = N_2; // [N/2+1..N-1]

    for (int s = 1; s <= n - 2; s++) {
        int idx = 1 << (n - s - 1);
        int vm  = 1 << s;

        padvance(a, 2*idx);

        for (int k = 1; k <= idx; k++) {
            float s1 = 0.0;
            float s2 = 0.0;
            for (int j = 0; j <= 2 * idx - 1; j++) {
                s1 += a[2 * idx + j] *
                    A[Cos + ((2 * k - 1) * vm * j) % sz];
            }
            for (int j = 1; j <= 2 * idx - 1; j++) {
                s2 += a[2 * idx + j] *
                    A[Sin + ((2 * k - 1) * vm * j) % sz];
            }
            int idx2 = (1 << (s - 1)) * (2 * k - 1);
            S[yoff + idx2]  = s1;
            S[_yoff + idx2] = s2;
        }
    }

    padvance(a, 1 << (n - (n-1)));
    S[yoff+(1 << (n - 2))]  = a[2];
    S[_yoff+(1 << (n - 2))] = a[3];

    padvance(a, 1 << (n - n));
    S[yoff + 0]             = a[0];
    S[yoff + N_2]           = a[1];

    for (int k = 0; k <= N_2; k++) {
        S[yoff + k] = S[yoff + k] * dx;
    }

    for (int k = 1; k <= N_2-1; k++) {
        S[_yoff + k] = S[_yoff + k] * dx;
    }

    for (int k = 1; k < N_2/2; k++) {
        float tmp = S[_yoff + k];
        S[_yoff + k] = S[_yoff+N_2-k];
        S[_yoff+N_2-k] = tmp;
    }
}

void sFFT(int ooff,int ioff, float dx, int N, int n, int nr) {
    for (int s = 1; s <= n - 1; s++) {
        int idx = 1 << (n - s);
        int vm  = 1 << (s - 1);
        sadvance(ioff, idx);

        for (int k = 1; k <= idx; k++) {
            float y = 0;
            for (int j = 1; j <= idx; j++) {
                y += A[ioff+idx * 2 - j] *
                    A[Sin+((2 * k - 1) * vm * nr * j) % sz];

            }
            A[ooff+(2 * k - 1) * vm] = y * dx;
        }
    }
    int idx = 1 << (n - 1);
    A[ooff+idx] = A[ioff+1] * dx;
}

void cFFT(int ooff, int ioff, float dx, int N, int n, int nr) {
    A[ioff+0] *= 0.5; A[ioff+N] *= 0.5; // samarskii, (15)-(16) p 66

    for (int s = 1; s <= n - 1; s++) {
        int idx = 1 << (n - s);
        int vm  = 1 << (s - 1);
        cadvance(ioff, idx);

        for (int k = 1; k <= idx; k++) {
            float y = 0;
            for (int j = 0; j <= idx - 1; j++) {
                y += A[ioff+idx * 2 - j] *
                    A[Cos+((2 * k - 1) * vm * nr * j) % sz];
            }
            A[ooff+(2 * k - 1) * vm] = y * dx;
        }
    }
    cadvance(ioff, 1 << (n-n));
    A[ooff+0]   = (A[ioff+0] + A[ioff+1]) * dx;
    A[ooff+N]   = (A[ioff+0] - A[ioff+1]) * dx;
    A[ooff+N/2] =  A[ioff+2] * dx;
}

void pFFT(int ooff, int ioff, float dx, int N, int n) {
    int N_2 = N/2;
    int k;

    cFFT(ooff, ioff, dx, N_2, n-1, 2);

    for (k = 1; k < N_2/2; k++) {
        float tmp = A[ioff+N_2 + k];
        A[ioff+N_2 + k] = A[ioff+N-k];
        A[ioff+N-k] = tmp;
    }

    // S[N_2] not filled, N_2+1 first non empty
    sFFT(ooff+N_2, ioff+N_2, dx, N_2, n-1, 2);

    for (k = 1; k <= N_2 - 1; k ++) {
        float S_k   = (A[ooff+k] + A[ooff+N_2+k]);
        float S_N_k = (A[ooff+k] - A[ooff+N_2+k]);
        A[ooff+k]    = S_k;
        A[ooff+N_2+k]= S_N_k;
    }
    for (int k = 1; k < N_2/2; k++) {
        float tmp = A[ooff+N_2 + k];
        A[ooff+N_2+k] = A[ooff+N-k];
        A[ooff+N  -k] = tmp;
    }
}

#define off(i,k,j) ((i)*rs*nn+(k)*rs+(j))

void main() {
    uint k = gl_LocalInvocationID.y; //gl_WorkGroupSize.y;
    uint j = gl_LocalInvocationID.x; //gl_WorkGroupSize.x;
    float slh = sqrt(2./l);

    if (k >= nn || j >= nn) {
        return;
    }

    float S[rs], s[rs];
    // along z
    for (int i = 0; i < nn; i++) {
        s[i] = A[In+off(i,k,j)];
    }
    pFFT_1(S,s,h*slh,nn,n);
    for (int i = 0; i < nn; i++) {
        A[Out+off(i,k,j)] = S[i];
    }
    barrier();

    // along y
    uint i = gl_LocalInvocationID.y;
    for (int k = 0; k < nn; k++) {
        s[k] = A[Out+off(i,k,j)];
    }
    pFFT_1(S,s,h*slh,nn,n);
    for (int k = 0; k < nn; k++) {
        A[Out+off(i,k,j)] = S[k];
    }
    barrier();

    // along x
    k = gl_LocalInvocationID.x;
    for (int j = 0; j < nn; j++) {
        s[j] = A[Out+off(i,k,j)];
    }
    pFFT_1(S,s,h*slh,nn,n);
    for (int j = 0; j < nn; j++) {
        A[Out+off(i,k,j)] = S[j];
    }
    barrier();
}
