#version 460

// TODO
layout(local_size_x = 32, local_size_y = 32) in;

layout(std140, binding=0) uniform Settings {
    vec4 origin;
    int particles;
    int stage;
    int nn;  // nx=ny=nz=nn
    int n;   // log(nn)
    float h;
    float l;
    float rho;
    float rcrit;
};

int sz = 2*nn;
// max grid size 1024x1024x1024
const float M_PI = 3.14159265359;
int Cos = 0;
int Sin = 2*nn;
int La = Sin+2*nn;

uint xsize = gl_NumWorkGroups.x*gl_WorkGroupSize.x;
uint ysize = gl_NumWorkGroups.y*gl_WorkGroupSize.y;
uint zsize = gl_NumWorkGroups.z*gl_WorkGroupSize.z;

uint globalIndex =
    gl_GlobalInvocationID.z*xsize*ysize+
    gl_GlobalInvocationID.y*xsize+
    gl_GlobalInvocationID.x;

layout(std430, binding=1) buffer FFTBuffer {
    float FFT[];
};

// work memory
layout(std430, binding=2) buffer WorkBuffer {
    float W[];
};

// density
layout(std430, binding=3) buffer DensityBuffer {
    float Rho[];
};

// potential
layout(std430, binding=4) buffer PotentialBuffer {
    float Psi[];
};

// field (w-component unused)
layout(std430, binding=5) buffer EBuffer {
    vec4 E[];
};

// positions, mass in w-coordinate
layout(std140, binding=6) buffer PosBuffer {
    vec4 Position[];
};

void padvance(uint ioff, int idx)
{
    for (int j = 0; j <= idx - 1; j++) {
        float a1 = W[ioff+j] + W[ioff+idx + j];
        float a2 = W[ioff+j] - W[ioff+idx + j];
        W[ioff+j]       = a1;
        W[ioff+idx + j] = a2;
    }
}

void sadvance(uint ioff, int idx) {
    for (int j = 1; j <= idx - 1; j ++) {
        float a1 = W[ioff+j] - W[ioff+2 * idx - j];
        float a2 = W[ioff+j] + W[ioff+2 * idx - j];
        W[ioff+j]           = a1;
        W[ioff+2 * idx - j] = a2;
    }
}

void cadvance(uint ioff, int idx) {
    for (int j = 0; j <= idx - 1; j ++) {
        float a1 = W[ioff+j] + W[ioff+2 * idx - j];
        float a2 = W[ioff+j] - W[ioff+2 * idx - j];
        W[ioff+j]           = a1;
        W[ioff+2 * idx - j] = a2;
    }
}

// fft s->S
void pFFT_1(uint ooff, uint ioff, float dx, int N, int n) {
    int N_2 = N/2;
    int yoff = 0; // [0..N/2]
    int _yoff = N_2; // [N/2+1..N-1]

    for (int s = 1; s <= n - 2; s++) {
        int idx = 1 << (n - s - 1);
        int vm  = 1 << s;

        padvance(ioff, 2*idx);

        for (int k = 1; k <= idx; k++) {
            float s1 = 0.0;
            float s2 = 0.0;
            for (int j = 0; j <= 2 * idx - 1; j++) {
                s1 += W[ioff+2 * idx + j] *
                    FFT[Cos + ((2 * k - 1) * vm * j) % sz];
            }
            for (int j = 1; j <= 2 * idx - 1; j++) {
                s2 += W[ioff+2 * idx + j] *
                    FFT[Sin + ((2 * k - 1) * vm * j) % sz];
            }
            int idx2 = (1 << (s - 1)) * (2 * k - 1);
            W[ooff+yoff + idx2]  = s1;
            W[ooff+_yoff + idx2] = s2;
        }
    }

    padvance(ioff, 1 << (n - (n-1)));
    W[ooff+yoff+(1 << (n - 2))]  = W[ioff+2];
    W[ooff+_yoff+(1 << (n - 2))] = W[ioff+3];

    padvance(ioff, 1 << (n - n));
    W[ooff+yoff + 0]             = W[ioff+0];
    W[ooff+yoff + N_2]           = W[ioff+1];

    for (int k = 0; k <= N_2; k++) {
        W[ooff+yoff + k] = W[ooff+yoff + k] * dx;
    }

    for (int k = 1; k <= N_2-1; k++) {
        W[ooff+_yoff + k] = W[ooff+_yoff + k] * dx;
    }

    for (int k = 1; k < N_2/2; k++) {
        float tmp = W[ooff+_yoff + k];
        W[ooff+_yoff + k] = W[ooff+_yoff+N_2-k];
        W[ooff+_yoff+N_2-k] = tmp;
    }
}

void sFFT(uint ooff, uint ioff, float dx, int N, int n, int nr) {
    for (int s = 1; s <= n - 1; s++) {
        int idx = 1 << (n - s);
        int vm  = 1 << (s - 1);
        sadvance(ioff, idx);

        for (int k = 1; k <= idx; k++) {
            float y = 0;
            for (int j = 1; j <= idx; j++) {
                y += W[ioff+idx * 2 - j] *
                    FFT[Sin+((2 * k - 1) * vm * nr * j) % sz];

            }
            W[ooff+(2 * k - 1) * vm] = y * dx;
        }
    }
    int idx = 1 << (n - 1);
    W[ooff+idx] = W[ioff+1] * dx;
}

void cFFT(uint ooff, uint ioff, float dx, int N, int n, int nr) {
    W[ioff+0] *= 0.5; W[ioff+N] *= 0.5; // samarskii, (15)-(16) p 66

    for (int s = 1; s <= n - 1; s++) {
        int idx = 1 << (n - s);
        int vm  = 1 << (s - 1);
        cadvance(ioff, idx);

        for (int k = 1; k <= idx; k++) {
            float y = 0;
            for (int j = 0; j <= idx - 1; j++) {
                y += W[ioff+idx * 2 - j] *
                    FFT[Cos+((2 * k - 1) * vm * nr * j) % sz];
            }
            W[ooff+(2 * k - 1) * vm] = y * dx;
        }
    }
    cadvance(ioff, 1 << (n-n));
    W[ooff+0]   = (W[ioff+0] + W[ioff+1]) * dx;
    W[ooff+N]   = (W[ioff+0] - W[ioff+1]) * dx;
    W[ooff+N/2] =  W[ioff+2] * dx;
}

void pFFT(uint ooff, uint ioff, float dx, int N, int n) {
    int N_2 = N/2;
    int k;

    cFFT(ooff, ioff, dx, N_2, n-1, 2);

    for (k = 1; k < N_2/2; k++) {
        float tmp = W[ioff+N_2 + k];
        W[ioff+N_2 + k] = W[ioff+N-k];
        W[ioff+N-k] = tmp;
    }

    // S[N_2] not filled, N_2+1 first non empty
    sFFT(ooff+N_2, ioff+N_2, dx, N_2, n-1, 2);

    for (k = 1; k <= N_2 - 1; k ++) {
        float S_k   = (W[ooff+k] + W[ooff+N_2+k]);
        float S_N_k = (W[ooff+k] - W[ooff+N_2+k]);
        W[ooff+k]    = S_k;
        W[ooff+N_2+k]= S_N_k;
    }
    for (int k = 1; k < N_2/2; k++) {
        float tmp = W[ooff+N_2 + k];
        W[ooff+N_2+k] = W[ooff+N-k];
        W[ooff+N  -k] = tmp;
    }
}

#define off(i,k,j) ((i)*nn*nn+(k)*nn+(j))
#define poff(i,k,j) (((i+nn)%nn)*nn*nn+((k+nn)%nn)*nn+((j+nn)%nn))

// TODO: size
const uint nl = 64; // 64 is max
shared uint locks[nl][nl];

void flush(in ivec4 ii, inout float Cur[2][2][2]) {
    for (int i = 0; i < 2; i++) {
        for (int k = 0; k < 2; k++) {
            for (int j = 0; j < 2; j ++) {
                int z0 = (ii.z+i)%nn;
                int y0 = (ii.y+k)%nn;
                int x0 = (ii.x+j)%nn;
                uint lk = 0;
                int it = 0;
                do {
                    lk = atomicCompSwap(locks[z0%nl][y0%nl], 0, 1+gl_LocalInvocationIndex);
                    if (lk == 0) {
                        Rho[off(z0,y0,x0)] += Cur[i][k][j];
                        atomicExchange(locks[z0%nl][y0%nl], 0);
                    }
                    it ++;
                } while (lk != 0 && it < 10000);
                Cur[i][k][j] = 0;
            }
        }
    }
}

void distribute(in vec4 x, inout ivec4 prev, inout float Cur[2][2][2]) {
    float M[2][2][2];
    float mass = x.w;
    x -= origin;
    ivec4 ii = ivec4(floor(x / h)); ii.w = 0;
    x = (x-ii*h)/h;

    if (prev.x != -1 && prev != ii) {
        flush(prev, Cur);
    }

    M[0][0][0] = (1-x.z)*(1-x.y)*(1-x.x);
    M[0][0][1] = (1-x.z)*(1-x.y)*(x.x);
    M[0][1][0] = (1-x.z)*(x.y)*(1-x.x);
    M[0][1][1] = (1-x.z)*(x.y)*(x.x);

    M[1][0][0] = (x.z)*(1-x.y)*(1-x.x);
    M[1][0][1] = (x.z)*(1-x.y)*(x.x);
    M[1][1][0] = (x.z)*(x.y)*(1-x.x);
    M[1][1][1] = (x.z)*(x.y)*(x.x);

    float G = 1; // TODO: uniform
    for (int i = 0; i < 2; i++) {
        for (int k = 0; k < 2; k++) {
            for (int j = 0; j < 2; j ++) {
                Cur[i][k][j] += 4*M_PI*G*mass * M[i][k][j];
            }
        }
    }

    prev = ii;
}

void mass_distribution() {
    uint i,k,j;
    // particles distribution

    k = gl_LocalInvocationID.y; i = gl_LocalInvocationID.x;

    // TODO: use workgroups
    uint kk = nn/32;
    for (uint y = 0; y < kk; y++) {
        for (uint x = 0; x < kk; x ++) {
            for (j = 0; j < nn; j++) {
                Rho[off(y*gl_WorkGroupSize.y+i,
                        x*gl_WorkGroupSize.x+k,j)] = 0; // -4*M_PI*rho;
            }

            locks[y*gl_WorkGroupSize.y+i][x*gl_WorkGroupSize.x+k] = 0;
        }
    }

    barrier();

    uint threads = xsize*ysize*zsize;
    uint work_size = (particles + threads - 1) / threads;
    uint from = globalIndex * work_size;
    uint to = from+work_size;
    ivec4 prev = ivec4(-1,-1,-1,-1);
    float Cur[2][2][2];
    for (int i = 0; i < 2; i++) {
        for (int k = 0; k < 2; k++) {
            for (int j = 0; j < 2; j ++) {
                Cur[i][k][j] = 0;
            }
        }
    }
    for (i = from; i < to && i < particles; i++) {
        distribute(Position[i], prev, Cur);
    }
    flush(prev, Cur);
}

void split(out uint i, out uint j) {
    i = gl_GlobalInvocationID.x;
    j = gl_GlobalInvocationID.y;
}

void main() {
    uint i,k,j;
    const float slh = sqrt(2./l);

    if (gl_GlobalInvocationID.y >= nn || gl_GlobalInvocationID.x >= nn) {
        return;
    }

    const uint _off = 2 * nn * globalIndex; // gl_LocalInvocationIndex;
    const uint ioff = _off;
    const uint ooff = _off+nn;

    if (stage == 1 || stage == 0) {
        mass_distribution(); barrier();
    }
    if (stage == 2 || stage == 0) {
        // along z
        split(k, j);
        for (i = 0; i < nn; i++) {
            W[ioff+i] = Rho[off(i,k,j)];
        }
        pFFT_1(ooff,ioff,h*slh,nn,n);
        for (i = 0; i < nn; i++) {
            Psi[off(i,k,j)] = W[ooff+i];
        }
        barrier();
    }
    if (stage == 3 || stage == 0) {
        // along y
        split(i, j);
        for (k = 0; k < nn; k++) {
            W[ioff+k] = Psi[off(i,k,j)];
        }
        pFFT_1(ooff,ioff,h*slh,nn,n);
        for (k = 0; k < nn; k++) {
            Psi[off(i,k,j)] = W[ooff+k];
        }
        barrier();
    }
    if (stage == 4 || stage == 0) {
        // along x
        split(i, k);
        for (j = 0; j < nn; j++) {
            W[ioff+j] = Psi[off(i,k,j)];
        }
        pFFT_1(ooff,ioff,h*slh,nn,n);
        for (j = 0; j < nn; j++) {
            Psi[off(i,k,j)] = W[ooff+j];
        }
        barrier();
    }
    if (stage == 5 || stage == 0) {
        split(i, k);
        for (j = 0; j < nn; j++) {
            Psi[off(i,k,j)] /= -FFT[La+i]-FFT[La+k]-FFT[La+j];
            //Psi[off(i,k,j)] *= exp((-FFT[La+i]-FFT[La+k]-FFT[La+j])*rcrit*rcrit);
            //Psi[off(i,k,j)] *= exp((-i*i-k*k-j*j)*rcrit*rcrit);
        }

        Psi[off(0,0,0)] = 1;
        barrier();
    }
    if (stage == 6 || stage == 0) {
        // along x
        split(i, k);
        for (j = 0; j < nn; j++) {
            W[ioff+j] = Psi[off(i,k,j)];
        }
        pFFT(ooff,ioff,slh,nn,n);
        for (j = 0; j < nn; j++) {
            Psi[off(i,k,j)] = W[ooff+j];
        }
        barrier();
    }
    if (stage == 7 || stage == 0) {
        // along y
        split(i, j);
        for (k = 0; k < nn; k++) {
            W[ioff+k] = Psi[off(i,k,j)];
        }
        pFFT(ooff,ioff,slh,nn,n);
        for (k = 0; k < nn; k++) {
            Psi[off(i,k,j)] = W[ooff+k];
        }
        barrier();
    }
    if (stage == 8 || stage == 0) {
        // along z
        split(k, j);
        for (i = 0; i < nn; i++) {
            W[ioff+i] = Psi[off(i,k,j)];
        }
        pFFT(ooff,ioff,slh,nn,n);
        for (i = 0; i < nn; i++) {
            Psi[off(i,k,j)] = W[ooff+i];
        }
        barrier();
    }
    if (stage == 9 || stage == 0) {
        // diff
        split(i, k);

        // TODO: use workgroups
        uint kk = nn/32;
        for (uint y = 0; y < kk; y++) {
            for (uint x = 0; x < kk; x ++) {
                uint i0 = y*gl_WorkGroupSize.y;
                uint k0 = x*gl_WorkGroupSize.x;
                for (j = 0; j < nn; j++) {
                    uint ii = off(i0+i,k0+k,j);
                    E[ii].x = -(Psi[poff(i0+i,k0+k,j+1)]-Psi[poff(i0+i,k0+k,j-1)])/2.0/h;
                    E[ii].y = -(Psi[poff(i0+i,k0+k+1,j)]-Psi[poff(i0+i,k0+k-1,j)])/2.0/h;
                    E[ii].z = -(Psi[poff(i0+i+1,k0+k,j)]-Psi[poff(i0+i-1,k0+k,j)])/2.0/h;
                    E[ii].w = 0; // unused
                }
            }
        }
        barrier();
    }
}
