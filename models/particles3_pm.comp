#version 460

// TODO
layout(local_size_x = 32, local_size_y = 32) in;

layout(std140, binding=0) uniform Settings {
    int nn;  // nx=ny=nz=nn
    int n;   // log(nn)
    float h;
    float l;
};

int sz = 2*nn;
// max grid size 1024x1024x1024
const float M_PI = 3.14159265359;
int Cos = 0;
int Sin = 2*nn;

layout(std430, binding=1) buffer FFTBuffer {
    float FFT[];
};

// work memory
layout(std430, binding=2) buffer WorkBuffer {
    float W[];
};

// density
layout(std430, binding=3) buffer DensityBuffer {
    float Rho[];
};

// potential
layout(std430, binding=4) buffer PotentialBuffer {
    float Psi[];
};

// field (w-component unused)
layout(std430, binding=5) buffer EBuffer {
    vec4 E[];
};

/*
struct Body {
    vec3 x;
    vec3 v;
    vec3 a;
    vec3 aprev;
    float mass;
    int enabled;
    ivec3 cellid;
};

struct Cell {
    int first_body;
    int nbodies;
};
*/

/*
layout(std430, binding=1) buffer BodiesBuffer {
    Body Bodies[];
};

layout(std430, binding=2) buffer CellsBuffer {
    Cell Cells[];
};

layout(std430, binding=3) buffer NodesBuffer {
    int Nodes[];
};
*/

void padvance(uint ioff, int idx)
{
    for (int j = 0; j <= idx - 1; j++) {
        float a1 = W[ioff+j] + W[ioff+idx + j];
        float a2 = W[ioff+j] - W[ioff+idx + j];
        W[ioff+j]       = a1;
        W[ioff+idx + j] = a2;
    }
}

void sadvance(uint ioff, int idx) {
    for (int j = 1; j <= idx - 1; j ++) {
        float a1 = W[ioff+j] - W[ioff+2 * idx - j];
        float a2 = W[ioff+j] + W[ioff+2 * idx - j];
        W[ioff+j]           = a1;
        W[ioff+2 * idx - j] = a2;
    }
}

void cadvance(uint ioff, int idx) {
    for (int j = 0; j <= idx - 1; j ++) {
        float a1 = W[ioff+j] + W[ioff+2 * idx - j];
        float a2 = W[ioff+j] - W[ioff+2 * idx - j];
        W[ioff+j]           = a1;
        W[ioff+2 * idx - j] = a2;
    }
}

// fft s->S
void pFFT_1(uint ooff, uint ioff, float dx, int N, int n) {
    int N_2 = N/2;
    int yoff = 0; // [0..N/2]
    int _yoff = N_2; // [N/2+1..N-1]

    for (int s = 1; s <= n - 2; s++) {
        int idx = 1 << (n - s - 1);
        int vm  = 1 << s;

        padvance(ioff, 2*idx);

        for (int k = 1; k <= idx; k++) {
            float s1 = 0.0;
            float s2 = 0.0;
            for (int j = 0; j <= 2 * idx - 1; j++) {
                s1 += W[ioff+2 * idx + j] *
                    FFT[Cos + ((2 * k - 1) * vm * j) % sz];
            }
            for (int j = 1; j <= 2 * idx - 1; j++) {
                s2 += W[ioff+2 * idx + j] *
                    FFT[Sin + ((2 * k - 1) * vm * j) % sz];
            }
            int idx2 = (1 << (s - 1)) * (2 * k - 1);
            W[ooff+yoff + idx2]  = s1;
            W[ooff+_yoff + idx2] = s2;
        }
    }

    padvance(ioff, 1 << (n - (n-1)));
    W[ooff+yoff+(1 << (n - 2))]  = W[ioff+2];
    W[ooff+_yoff+(1 << (n - 2))] = W[ioff+3];

    padvance(ioff, 1 << (n - n));
    W[ooff+yoff + 0]             = W[ioff+0];
    W[ooff+yoff + N_2]           = W[ioff+1];

    for (int k = 0; k <= N_2; k++) {
        W[ooff+yoff + k] = W[ooff+yoff + k] * dx;
    }

    for (int k = 1; k <= N_2-1; k++) {
        W[ooff+_yoff + k] = W[ooff+_yoff + k] * dx;
    }

    for (int k = 1; k < N_2/2; k++) {
        float tmp = W[ooff+_yoff + k];
        W[ooff+_yoff + k] = W[ooff+_yoff+N_2-k];
        W[ooff+_yoff+N_2-k] = tmp;
    }
}

void sFFT(uint ooff, uint ioff, float dx, int N, int n, int nr) {
    for (int s = 1; s <= n - 1; s++) {
        int idx = 1 << (n - s);
        int vm  = 1 << (s - 1);
        sadvance(ioff, idx);

        for (int k = 1; k <= idx; k++) {
            float y = 0;
            for (int j = 1; j <= idx; j++) {
                y += W[ioff+idx * 2 - j] *
                    FFT[Sin+((2 * k - 1) * vm * nr * j) % sz];

            }
            W[ooff+(2 * k - 1) * vm] = y * dx;
        }
    }
    int idx = 1 << (n - 1);
    W[ooff+idx] = W[ioff+1] * dx;
}

void cFFT(uint ooff, uint ioff, float dx, int N, int n, int nr) {
    W[ioff+0] *= 0.5; W[ioff+N] *= 0.5; // samarskii, (15)-(16) p 66

    for (int s = 1; s <= n - 1; s++) {
        int idx = 1 << (n - s);
        int vm  = 1 << (s - 1);
        cadvance(ioff, idx);

        for (int k = 1; k <= idx; k++) {
            float y = 0;
            for (int j = 0; j <= idx - 1; j++) {
                y += W[ioff+idx * 2 - j] *
                    FFT[Cos+((2 * k - 1) * vm * nr * j) % sz];
            }
            W[ooff+(2 * k - 1) * vm] = y * dx;
        }
    }
    cadvance(ioff, 1 << (n-n));
    W[ooff+0]   = (W[ioff+0] + W[ioff+1]) * dx;
    W[ooff+N]   = (W[ioff+0] - W[ioff+1]) * dx;
    W[ooff+N/2] =  W[ioff+2] * dx;
}

void pFFT(uint ooff, uint ioff, float dx, int N, int n) {
    int N_2 = N/2;
    int k;

    cFFT(ooff, ioff, dx, N_2, n-1, 2);

    for (k = 1; k < N_2/2; k++) {
        float tmp = W[ioff+N_2 + k];
        W[ioff+N_2 + k] = W[ioff+N-k];
        W[ioff+N-k] = tmp;
    }

    // S[N_2] not filled, N_2+1 first non empty
    sFFT(ooff+N_2, ioff+N_2, dx, N_2, n-1, 2);

    for (k = 1; k <= N_2 - 1; k ++) {
        float S_k   = (W[ooff+k] + W[ooff+N_2+k]);
        float S_N_k = (W[ooff+k] - W[ooff+N_2+k]);
        W[ooff+k]    = S_k;
        W[ooff+N_2+k]= S_N_k;
    }
    for (int k = 1; k < N_2/2; k++) {
        float tmp = W[ooff+N_2 + k];
        W[ooff+N_2+k] = W[ooff+N-k];
        W[ooff+N  -k] = tmp;
    }
}

#define off(i,k,j) ((i)*nn*nn+(k)*nn+(j))
#define poff(i,k,j) (((i+nn)%nn)*nn*nn+((k+nn)%nn)*nn+((j+nn)%nn))

void main() {
    uint i,k,j;
    const float slh = sqrt(2./l);

    if (gl_LocalInvocationID.y >= nn || gl_LocalInvocationID.x >= nn) {
        return;
    }

    const uint off = 2 * nn * gl_LocalInvocationIndex;
    const uint ioff = off;
    const uint ooff = off+nn;
    // along z

    k = gl_LocalInvocationID.y; j = gl_LocalInvocationID.x;
    for (i = 0; i < nn; i++) {
        W[ioff+i] = Rho[off(i,k,j)];
    }
    pFFT_1(ooff,ioff,h*slh,nn,n);
    for (i = 0; i < nn; i++) {
        Psi[off(i,k,j)] = W[ooff+i];
    }
    barrier();

    // along y
    i = gl_LocalInvocationID.y; j = gl_LocalInvocationID.x;
    for (k = 0; k < nn; k++) {
        W[ioff+k] = Psi[off(i,k,j)];
    }
    pFFT_1(ooff,ioff,h*slh,nn,n);
    for (k = 0; k < nn; k++) {
        Psi[off(i,k,j)] = W[ooff+k];
    }
    barrier();

    // along x
    i = gl_LocalInvocationID.y; k = gl_LocalInvocationID.x;
    for (j = 0; j < nn; j++) {
        W[ioff+j] = Psi[off(i,k,j)];
    }
    pFFT_1(ooff,ioff,h*slh,nn,n);
    for (j = 0; j < nn; j++) {
        Psi[off(i,k,j)] = W[ooff+j];
    }
    barrier();

    i = gl_LocalInvocationID.y; k = gl_LocalInvocationID.x;
    for (j = 0; j < nn; j++) {
        // k2 = 0
        vec3 kk = vec3(
            2*i*M_PI/l, 2*k*M_PI/l, 2*j*M_PI/l
            );
        Psi[off(i,k,j)] /= -dot(kk,kk);
    }

    Psi[off(0,0,0)] = 1;
    barrier();

    // along x
    i = gl_LocalInvocationID.y; k = gl_LocalInvocationID.x;
    for (j = 0; j < nn; j++) {
        W[ioff+j] = Psi[off(i,k,j)];
    }
    pFFT(ooff,ioff,slh,nn,n);
    for (j = 0; j < nn; j++) {
        Psi[off(i,k,j)] = W[ooff+j];
    }
    barrier();

    // along y
    i = gl_LocalInvocationID.y; j = gl_LocalInvocationID.x;
    for (k = 0; k < nn; k++) {
        W[ioff+k] = Psi[off(i,k,j)];
    }
    pFFT(ooff,ioff,slh,nn,n);
    for (k = 0; k < nn; k++) {
        Psi[off(i,k,j)] = W[ooff+k];
    }
    barrier();

    // along z
    k = gl_LocalInvocationID.y; j = gl_LocalInvocationID.x;
    for (i = 0; i < nn; i++) {
        W[ioff+i] = Psi[off(i,k,j)];
    }
    pFFT(ooff,ioff,slh,nn,n);
    for (i = 0; i < nn; i++) {
        Psi[off(i,k,j)] = W[ooff+i];
    }
    barrier();

    // diff
    i = gl_LocalInvocationID.y; k = gl_LocalInvocationID.x;
    for (j = 0; j < nn; j++) {
        E[off(i,k,j)].x = -(Psi[poff(i,k,j+1)]-Psi[poff(i,k,j-1)])/2.0/h;
        E[off(i,k,j)].y = -(Psi[poff(i,k+1,j)]-Psi[poff(i,k-1,j)])/2.0/h;
        E[off(i,k,j)].z = -(Psi[poff(i+1,k,j)]-Psi[poff(i-1,k,j)])/2.0/h;
        E[off(i,k,j)].w = 0; // unused
    }

    barrier();
}
