#version 430

layout(local_size_x = 1024, local_size_y = 1024) in;

layout(std140, binding=0) uniform Settings {
    int nn;  // nx=ny=nz=nn
    int n;   // log(nn)
    int Out; // fft output
    int In;  // fft input
    int Cos; // cos table for fft
    int Sin; // sin table for fft
    float h;
    float l;
};

int sz = 2*nn;
// max grid size 1024x1024x1024
const int rs = 1024;
const float M_PI = 3.14159265359;

// density + psi + sin/cos tables
layout(std430, binding=1) buffer DensityBuffer {
    float A[];
};

// field (w-component unused)
layout(std430, binding=2) buffer EBuffer {
    vec4 E[];
};

/*
struct Body {
    vec3 x;
    vec3 v;
    vec3 a;
    vec3 aprev;
    float mass;
    int enabled;
    ivec3 cellid;
};

struct Cell {
    int first_body;
    int nbodies;
};
*/

/*
layout(std430, binding=1) buffer BodiesBuffer {
    Body Bodies[];
};

layout(std430, binding=2) buffer CellsBuffer {
    Cell Cells[];
};

layout(std430, binding=3) buffer NodesBuffer {
    int Nodes[];
};
*/

void padvance(inout float a[rs], int idx)
{
    for (int j = 0; j <= idx - 1; j++) {
        float a1 = a[j] + a[idx + j];
        float a2 = a[j] - a[idx + j];
        a[j]       = a1;
        a[idx + j] = a2;
    }
}

void sadvance(inout float a[rs], int ioff, int idx) {
    for (int j = 1; j <= idx - 1; j ++) {
        float a1 = a[ioff+j] - a[ioff+2 * idx - j];
        float a2 = a[ioff+j] + a[ioff+2 * idx - j];
        a[ioff+j]           = a1;
        a[ioff+2 * idx - j] = a2;
    }
}

void cadvance(inout float a[rs], int ioff, int idx) {
    for (int j = 0; j <= idx - 1; j ++) {
        float a1 = a[ioff+j] + a[ioff+2 * idx - j];
        float a2 = a[ioff+j] - a[ioff+2 * idx - j];
        a[ioff+j]           = a1;
        a[ioff+2 * idx - j] = a2;
    }
}

// fft s->S
void pFFT_1(inout float S[rs], inout float a[rs], float dx, int N, int n) {
    int N_2 = N/2;
    int yoff = 0; // [0..N/2]
    int _yoff = N_2; // [N/2+1..N-1]

    for (int s = 1; s <= n - 2; s++) {
        int idx = 1 << (n - s - 1);
        int vm  = 1 << s;

        padvance(a, 2*idx);

        for (int k = 1; k <= idx; k++) {
            float s1 = 0.0;
            float s2 = 0.0;
            for (int j = 0; j <= 2 * idx - 1; j++) {
                s1 += a[2 * idx + j] *
                    A[Cos + ((2 * k - 1) * vm * j) % sz];
            }
            for (int j = 1; j <= 2 * idx - 1; j++) {
                s2 += a[2 * idx + j] *
                    A[Sin + ((2 * k - 1) * vm * j) % sz];
            }
            int idx2 = (1 << (s - 1)) * (2 * k - 1);
            S[yoff + idx2]  = s1;
            S[_yoff + idx2] = s2;
        }
    }

    padvance(a, 1 << (n - (n-1)));
    S[yoff+(1 << (n - 2))]  = a[2];
    S[_yoff+(1 << (n - 2))] = a[3];

    padvance(a, 1 << (n - n));
    S[yoff + 0]             = a[0];
    S[yoff + N_2]           = a[1];

    for (int k = 0; k <= N_2; k++) {
        S[yoff + k] = S[yoff + k] * dx;
    }

    for (int k = 1; k <= N_2-1; k++) {
        S[_yoff + k] = S[_yoff + k] * dx;
    }

    for (int k = 1; k < N_2/2; k++) {
        float tmp = S[_yoff + k];
        S[_yoff + k] = S[_yoff+N_2-k];
        S[_yoff+N_2-k] = tmp;
    }
}

void sFFT(inout float S[rs], inout float a[rs], int ooff,int ioff, float dx, int N, int n, int nr) {
    for (int s = 1; s <= n - 1; s++) {
        int idx = 1 << (n - s);
        int vm  = 1 << (s - 1);
        sadvance(a, ioff, idx);

        for (int k = 1; k <= idx; k++) {
            float y = 0;
            for (int j = 1; j <= idx; j++) {
                y += S[ioff+idx * 2 - j] *
                    A[Sin+((2 * k - 1) * vm * nr * j) % sz];

            }
            S[ooff+(2 * k - 1) * vm] = y * dx;
        }
    }
    int idx = 1 << (n - 1);
    S[ooff+idx] = a[ioff+1] * dx;
}

void cFFT(inout float S[rs], inout float a[rs], int ooff, int ioff, float dx, int N, int n, int nr) {
    a[ioff+0] *= 0.5; a[ioff+N] *= 0.5; // samarskii, (15)-(16) p 66

    for (int s = 1; s <= n - 1; s++) {
        int idx = 1 << (n - s);
        int vm  = 1 << (s - 1);
        cadvance(a, ioff, idx);

        for (int k = 1; k <= idx; k++) {
            float y = 0;
            for (int j = 0; j <= idx - 1; j++) {
                y += a[ioff+idx * 2 - j] *
                    A[Cos+((2 * k - 1) * vm * nr * j) % sz];
            }
            S[ooff+(2 * k - 1) * vm] = y * dx;
        }
    }
    cadvance(a, ioff, 1 << (n-n));
    S[ooff+0]   = (a[ioff+0] + a[ioff+1]) * dx;
    S[ooff+N]   = (a[ioff+0] - a[ioff+1]) * dx;
    S[ooff+N/2] =  a[ioff+2] * dx;
}

void pFFT(inout float S[rs], inout float a[rs], float dx, int N, int n) {
    int N_2 = N/2;
    int k;

    cFFT(S, a, 0, 0, dx, N_2, n-1, 2);

    for (k = 1; k < N_2/2; k++) {
        float tmp = a[N_2 + k];
        a[N_2 + k] = a[N-k];
        a[N-k] = tmp;
    }

    // S[N_2] not filled, N_2+1 first non empty
    sFFT(S, a, N_2, N_2, dx, N_2, n-1, 2);

    for (k = 1; k <= N_2 - 1; k ++) {
        float S_k   = (S[k] + S[N_2+k]);
        float S_N_k = (S[k] - S[N_2+k]);
        S[k]    = S_k;
        S[N_2+k]= S_N_k;
    }
    for (int k = 1; k < N_2/2; k++) {
        float tmp = S[N_2 + k];
        S[N_2+k] = S[N-k];
        S[N  -k] = tmp;
    }
}

#define off(i,k,j) ((i)*rs*nn+(k)*rs+(j))

void main() {
    uint i,k,j;
    float slh = sqrt(2./l);

    if (k >= nn || j >= nn) {
        return;
    }

    float S[rs], s[rs];
    // along z
    k = gl_LocalInvocationID.y; j = gl_LocalInvocationID.x;
    for (int i = 0; i < nn; i++) {
        s[i] = A[In+off(i,k,j)];
    }
    pFFT_1(S,s,h*slh,nn,n);
    for (int i = 0; i < nn; i++) {
        A[Out+off(i,k,j)] = S[i];
    }
    barrier();

    // along y
    i = gl_LocalInvocationID.y; k = gl_LocalInvocationID.y;
    for (int k = 0; k < nn; k++) {
        s[k] = A[Out+off(i,k,j)];
    }
    pFFT_1(S,s,h*slh,nn,n);
    for (int k = 0; k < nn; k++) {
        A[Out+off(i,k,j)] = S[k];
    }
    barrier();

    // along x
    k = gl_LocalInvocationID.y; j = gl_LocalInvocationID.x;
    for (int j = 0; j < nn; j++) {
        s[j] = A[Out+off(i,k,j)];
    }
    pFFT_1(S,s,h*slh,nn,n);
    for (int j = 0; j < nn; j++) {
        A[Out+off(i,k,j)] = S[j];
    }
    barrier();

    for (int j = 0; j < nn; j++) {
        // k2 = 0
        vec3 kk = vec3(
            2*i*M_PI/l, 2*k*M_PI/l, 2*j*M_PI/l
            );
        A[Out+off(i,k,j)] /= -dot(kk,kk);
    }

    A[Out+off(0,0,0)] = 1;
    barrier();

    // along x
    k = gl_LocalInvocationID.y; j = gl_LocalInvocationID.x;
    for (int j = 0; j < nn; j++) {
        s[j] = A[Out+off(i,k,j)];
    }
    pFFT(S,s,slh,nn,n);
    for (int j = 0; j < nn; j++) {
        A[Out+off(i,k,j)] = S[j];
    }
    barrier();

    // along y
    i = gl_LocalInvocationID.y; k = gl_LocalInvocationID.y;
    for (int k = 0; k < nn; k++) {
        s[k] = A[Out+off(i,k,j)];
    }
    //pFFT(S,s,slh,nn,n);
    for (int k = 0; k < nn; k++) {
        A[Out+off(i,k,j)] = S[k];
    }
    barrier();

    // along z
    k = gl_LocalInvocationID.y; j = gl_LocalInvocationID.x;
    for (int i = 0; i < nn; i++) {
        s[i] = A[Out+off(i,k,j)];
    }
    //pFFT(S,s,slh,nn,n);
    for (int i = 0; i < nn; i++) {
        A[Out+off(i,k,j)] = S[i];
    }
    barrier();
}
