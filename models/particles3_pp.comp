#version 460

// TODO
layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(std140, binding=0) uniform Settings {
    vec4 origin;
    int particles;
    int stage;
    int nn; // nn for chain-grid
    float h; // h for chain-grid
    float rcrit;
};

const float G = 1; // TODO
uint xsize = gl_NumWorkGroups.x*gl_WorkGroupSize.x;
uint ysize = gl_NumWorkGroups.y*gl_WorkGroupSize.y;
uint zsize = gl_NumWorkGroups.z*gl_WorkGroupSize.z;

uint globalIndex =
    gl_GlobalInvocationID.z*xsize*ysize+
    gl_GlobalInvocationID.y*xsize+
    gl_GlobalInvocationID.x;


const uint max_per_cell = 1023;
struct Cell {
    uint indices[max_per_cell];
    uint n;
};

layout(std430, binding=1) buffer CellsBuffer {
    Cell cells[];
};

// positions, mass in w-coordinate
layout(std430, binding=2) buffer PosBuffer {
    vec4 Position[];
};

layout(std430, binding=3) buffer ForceBuffer {
    vec4 F[];
};

const uint nl = 64*64;
shared uint locks[nl];

// per-thread chain
const uint max_size = 128;
uint cur[max_size];
uint cur_size = 0;
ivec3 prev_index;

#define off(i,k,j) ((i)*nn*nn+(k)*nn+(j))
#define poff(i,k,j) (((i+nn)%nn)*nn*nn+((k+nn)%nn)*nn+((j+nn)%nn))

void flush(in ivec3 index) {
    uint lk = 0;
    int it = 0; // protection GPU hang
    const uint cell_id = poff(index.z,index.y,index.x);
    if (cells[cell_id].n >= max_per_cell) {
        cur_size = 0;
        return;
    }
    do {
        lk = atomicCompSwap(locks[cell_id%nl], 0, 1+gl_LocalInvocationIndex);
        if (lk == 0) {
            uint n = cells[cell_id].n;
            uint i = 0;
            for (i = 0; i < cur_size && (i+n)<max_per_cell; i++) {
                cells[cell_id].indices[i+n] = cur[i];
            }
            cells[cell_id].n = n+i;
            atomicExchange(locks[cell_id%nl], 0);
        }
        it ++;
    } while (lk != 0 && it < 10000);
    cur_size = 0;
}

void place(in vec4 x, uint i) {
    x -= origin;
    ivec3 index = ivec3(floor(x / h)); // -> cell index
    if (prev_index.x != -1 && (prev_index != index || cur_size >= max_size)) {
        flush(prev_index);
    }

    cur[cur_size++] = i;

    prev_index = index;
}

// TODO: periodic boundary (see off[] in cpu-version)
void process(uint id, uint other, int from, int to) {
    uint i0,j0;
    const float eps = 0.001; // TODO
    const uint n1 = cells[id].n;
    const uint n2 = cells[other].n;

    for (i0 = from; i0 < to && i0 < n1; i0++) {
        uint i = cells[id].indices[i0];
        vec3 ri = vec3(Position[i]);

        for (j0 = 0; j0 < n2; j0++) {
            uint j = cells[other].indices[j0];
            if (i != j) {
                vec3 rj = vec3(Position[j]);
                float R = length(rj-ri);
                R += eps;
                if (R < rcrit) {
                    F[i] += - Position[j].w * G * vec4((ri-rj),0)/R/R/R;
                }
            }
        }
    }
}

void calc_force_single()
{
    int i,k,j;
    int i0,k0,j0;

    i = int(gl_LocalInvocationID.y);
    k = int(gl_LocalInvocationID.x);

    for (j = 0; j < nn; j++) {
        const uint id = off(i,k,j);
        const int n1 = int(cells[id].n);
        for (i0 = 0; i0 < n1; i0++) {
            F[cells[id].indices[i0]] = vec4(0);
        }
        for (i0 = -1; i0 <= 1; i0++) {
            for (k0 = -1; k0 <= 1; k0++) {
                for (j0 = -1; j0 <= 1; j0++) {
                    process(off(i,k,j), poff(i+i0,k+k0,j+j0), 0, n1);
                }
            }
        }
    }
}

void calc_force()
{
    int i,k,j;
    int i0,k0,j0;

    i = int(gl_WorkGroupID.z);
    k = int(gl_WorkGroupID.y);
    j = int(gl_WorkGroupID.x);

    uint threads = gl_WorkGroupSize.x*gl_WorkGroupSize.y*gl_WorkGroupSize.z;

    const int id = off(i,k,j);
    const uint n1 = cells[id].n;
    int work_size = int((n1+threads-1)/threads);
    int from = int(gl_LocalInvocationIndex*work_size);
    int to = from+work_size;
    for (i0 = from; i0 < to; i0++) {
        F[cells[id].indices[i0]] = vec4(0);
    }
    for (i0 = -1; i0 <= 1; i0++) {
        for (k0 = -1; k0 <= 1; k0++) {
            for (j0 = -1; j0 <= 1; j0++) {
                process(id, poff(i+i0,k+k0,j+j0), from, to);
            }
        }
    }
}

void main() {
    uint kk = 2; // 64/32 TODO: const
    uint i,k,j;

    if (stage == 1 || stage == 0) {
        i = gl_LocalInvocationID.y;
        j = gl_LocalInvocationID.x;
        for (uint y = 0; y < kk; y++) {
            for (uint x = 0; x < kk; x ++) {
                locks[64*(y*32+i)+x*32+j] = 0;
            }
        }
        i = gl_LocalInvocationID.y;
        k = gl_LocalInvocationID.x;
        for (j = 0; j < nn; j++) {
            cells[off(i,k,j)].n = 0;
        }

        barrier();

        // 1. "sort" points
        uint threads = xsize*ysize*zsize;
        uint work_size = (particles + threads - 1) / threads;
        uint from = globalIndex * work_size;
        uint to = from+work_size;
        cur_size = 0;
        prev_index = ivec3(-1,-1,-1);
        for (i = from; i < to && i < particles; i++) {
            place(Position[i], i);
        }
        flush(prev_index);
        // 2. use sorted
        barrier();
    }

    if (stage == 0) {
        calc_force_single();
    } else if (stage == 2) {
        calc_force();
    }
}
