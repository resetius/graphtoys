#version 460

// TODO
layout(local_size_x = 32, local_size_y = 32) in;

layout(std140, binding=0) uniform Settings {
    vec4 origin;
    int particles;
    int nn; // nn for chain-grid
    float h; // h for chain-grid
    float rcrit;
};

const float G = 1; // TODO
uint xsize = gl_NumWorkGroups.x*gl_WorkGroupSize.x;
uint ysize = gl_NumWorkGroups.y*gl_WorkGroupSize.y;
uint zsize = gl_NumWorkGroups.z*gl_WorkGroupSize.z;

uint globalIndex =
    gl_GlobalInvocationID.z*xsize*ysize+
    gl_GlobalInvocationID.y*xsize+
    gl_GlobalInvocationID.x;


const uint max_per_cell = 1023;
struct Cell {
    uint indices[max_per_cell];
    uint n;
};

layout(std430, binding=1) buffer CellsBuffer {
    Cell cells[];
};

// positions, mass in w-coordinate
layout(std430, binding=2) buffer PosBuffer {
    vec4 Position[];
};

layout(std430, binding=3) buffer ForceBuffer {
    vec4 F[];
};

const uint nl = 64*64;
shared uint locks[nl];

// per-thread chain
const uint max_size = 128;
uint cur[max_size];
uint cur_size = 0;
ivec3 prev_index;

#define off(i,k,j) ((i)*nn*nn+(k)*nn+(j))
#define poff(i,k,j) (((i+nn)%nn)*nn*nn+((k+nn)%nn)*nn+((j+nn)%nn))

void flush(in ivec3 index) {
    uint lk = 0;
    int it = 0; // protection GPU hang
    const uint cell_id = off(index.z,index.y,index.x);
    if (cells[cell_id].n >= max_per_cell) {
        cur_size = 0;
        return;
    }
    do {
        lk = atomicCompSwap(locks[cell_id%nl], 0, 1+gl_LocalInvocationIndex);
        if (lk == 0) {
            uint n = cells[cell_id].n;
            for (uint i = 0; i < cur_size && (i+n)<max_per_cell; i++) {
                cells[cell_id].indices[i+n] = cur[i];
            }
            cells[cell_id].n = n+cur_size;
            atomicExchange(locks[cell_id%nl], 0);
        }
        it ++;
    } while (lk != 0 && it < 10000);
    cur_size = 0;
}

void place(in vec4 x, uint i) {
    x -= origin;
    ivec3 index = ivec3(floor(x / h)); // -> cell index
    if (prev_index.x != -1 && (prev_index != index || cur_size >= max_size)) {
        flush(prev_index);
    }

    cur[cur_size++] = i;

    prev_index = index;
}

// TODO: periodic boundary (see off[] in cpu-version)
void process(in Cell cell, in Cell other) {
    uint i0,j0;
    const float eps = 0.001; // TODO
    for (i0 = 0; i0 < cell.n; i0++) {
        uint i = cell.indices[i0];
        F[i] = vec4(0);
        for (j0 = 0; j0 < other.n; j0++) {
            uint j = other.indices[j0];
            float R = length(vec3(Position[j])-vec3(Position[i]));
            R = sqrt(R)+eps;
            if (R < rcrit) {
                F[i] += - Position[j].w * G * (Position[i]-Position[j])/R/R/R;
            }
        }
    }
}

void calc_force()
{
    int i,k,j;
    int i0,k0,j0;

    i = int(gl_LocalInvocationID.x);
    k = int(gl_LocalInvocationID.y);

    for (j = 0; j < nn; j++) {
        for (i0 = -1; i0 <= 1; i0++) {
            for (k0 = -1; k0 <= 1; k0++) {
                for (j0 = -1; j0 <= 1; j0++) {
                    process(cells[off(i,k,j)], cells[poff(i+i0,k+k0,j+j0)]);
                }
            }
        }
    }
}

void main() {
    uint kk = 2; // 64/32 TODO: const
    uint i,k,j;
    i = gl_LocalInvocationID.y;
    j = gl_LocalInvocationID.x;
    for (uint y = 0; y < kk; y++) {
        for (uint x = 0; x < kk; x ++) {
            locks[64*(y*32+i)+x*32+j] = 0;
        }
    }
    i = gl_LocalInvocationID.y;
    k = gl_LocalInvocationID.x;
    for (j = 0; j < nn; j++) {
        cells[off(i,k,j)].n = 0;
    }
    barrier();

    // 1. "sort" points
    uint threads = xsize*ysize*zsize;
    uint from =  globalIndex * particles / threads;
    uint to = globalIndex * (particles + threads - 1) / threads;
    cur_size = 0;
    prev_index = ivec3(-1,-1,-1);
    for (i = from; i < to && i < particles; i++) {
        place(Position[i], i);
        //F[i].y= 1000;
    }
    flush(prev_index);
    // 2. use sorted
    barrier();

    calc_force();
}
