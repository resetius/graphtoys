#version 460

// TODO
layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(std140, binding=0) uniform Settings {
    vec4 origin;
    int particles;
    int cell_size;
    int stage;
    int nn; // nn for chain-grid
    float h; // h for chain-grid
    float l;
    float rcrit;
};

const float G = 1; // TODO
uint xsize = gl_NumWorkGroups.x*gl_WorkGroupSize.x;
uint ysize = gl_NumWorkGroups.y*gl_WorkGroupSize.y;
uint zsize = gl_NumWorkGroups.z*gl_WorkGroupSize.z;

uint globalIndex =
    gl_GlobalInvocationID.z*xsize*ysize+
    gl_GlobalInvocationID.y*xsize+
    gl_GlobalInvocationID.x;

layout(std430, binding=1) buffer CellsBuffer {
    uint cell_data[];
};

// positions, mass in w-coordinate
layout(std430, binding=2) readonly buffer PosBuffer {
    vec4 Position[];
};

layout(std430, binding=3) buffer ForceBuffer {
    vec4 F[];
};

layout(std430, binding=4) buffer ListBuffer {
    int list[];
};

uint max_per_cell = cell_size-1;
const uint nl = 32;
shared int lists[nl][nl];

#define off(i,k,j) ((i)*nn*nn+(k)*nn+(j))
#define poff(i,k,j) (((i+nn)%nn)*nn*nn+((k+nn)%nn)*nn+((j+nn)%nn))

// erf from: https://www.cs.uaf.edu/2010/spring/cs481/section/1/lecture/02_23_planet.html
const float M_PI=3.1415926535;
const float a=8.0*(M_PI-3.0)/(3.0*M_PI*(4.0-M_PI));
float erf_guts(float x) {
    float x2=x*x;
    return exp(-x2 * (4.0/M_PI + a*x2) / (1.0+a*x2));
}
float erf(float x) {
    float sign=1.0;
    if (x<0.0) sign=-1.0;
    return sign*sqrt(1.0-erf_guts(x));
}
float erfc(float x) {
   if (x>3.0) {
      return 0.5*erf_guts(x);
   } else {
      return 1.0-erf(x);
   }
}

uint mx = 128;
shared vec4 coords[128];

void process(uint id, uint other, vec3 dh, int from, int to) {
    uint i0,j0;
    const float eps = 0.001; // TODO
    const uint n1 = cell_data[id*cell_size];
    const uint n2 = cell_data[other*cell_size];
/*
    for (j0 = 0; j0 < n2 && j0 < max_per_cell; j0++) {
        coords[j0] = Position[cell_data[other*cell_size+j0+1]];
    }

    barrier();
*/
    for (i0 = from; i0 < to && i0 < n1 && i0 < max_per_cell; i0++) {
        uint i = cell_data[id*cell_size+i0+1];
        vec3 ri = vec3(Position[i]) + dh;

        for (j0 = 0; j0 < n2 && j0 < max_per_cell; j0++) {
            uint j = cell_data[other*cell_size+j0+1];
            if (i != j) {
                vec3 rj = vec3(Position[j]);
                float mass = Position[j].w;
                //vec3 rj = vec3(coords[j0]);
                //float mass = coords[j0].w;
                float R = length(rj-ri);
                R += eps;
                if (R < rcrit) {
                    float kk = erfc(R/2/rcrit)
                        +R/rcrit/sqrt(M_PI)*exp(-R*R/4/rcrit/rcrit);
                    //float kk = 1;
                    F[i] += - mass * G * kk * vec4((ri-rj),0)/R/R/R;
                }
            }
        }
    }
}

// periodicity
void calc_off(inout vec3 dh, int i, int k, int j) {
    dh = vec3(0);
    if (i < 0)   dh.z = -l;
    if (i >= nn) dh.z =  l;
    if (k < 0)   dh.y = -l;
    if (k >= nn) dh.y =  l;
    if (j < 0)   dh.x = -l;
    if (j >= nn) dh.x =  l;
}

void calc_force_single()
{
    int i,k,j;
    int i0,k0,j0;
    vec3 dh = vec3(0);

    i = int(gl_LocalInvocationID.y);
    k = int(gl_LocalInvocationID.x);

    for (j = 0; j < nn; j++) {
        const uint id = off(i,k,j);
        const uint n1 = cell_data[id*cell_size];
        for (i0 = 0; i0 < n1; i0++) {
            F[cell_data[id*cell_size+i0+1]] = vec4(0);
        }
        for (i0 = -1; i0 <= 1; i0++) {
            for (k0 = -1; k0 <= 1; k0++) {
                for (j0 = -1; j0 <= 1; j0++) {
                    calc_off(dh, i+i0, k+k0, j+j0);
                    process(off(i,k,j), poff(i+i0,k+k0,j+j0), dh, 0, int(n1));
                }
            }
        }
    }
}

void calc_force_(int i, int k, int j)
{
    int i0,k0,j0;
    vec3 dh = vec3(0);

    //uint threads = gl_WorkGroupSize.x*gl_WorkGroupSize.y*gl_WorkGroupSize.z;
    //uint threads = gl_WorkGroupSize.y;
    uint threads = gl_NumWorkGroups.y;

    const int id = off(i,k,j);
    const uint n1 = cell_data[id*cell_size];
    int work_size = int((n1+threads-1)/threads);
    //int from = int(gl_LocalInvocationIndex*work_size);
    //int from = int(gl_LocalInvocationID.y*work_size);
    int from = int(gl_WorkGroupID.y*work_size);
    int to = min(from+work_size,particles);
    //int from = 0; int to = int(n1);
    for (i0 = from; i0 < to; i0++) {
        F[cell_data[id*cell_size+i0+1]] = vec4(0);
    }
    for (i0 = -1; i0 <= 1; i0++) {
        for (k0 = -1; k0 <= 1; k0++) {
            for (j0 = -1; j0 <= 1; j0++) {
                calc_off(dh, i+i0, k+k0, j+j0);
                process(id, poff(i+i0,k+k0,j+j0), dh, from, to);
            }
        }
    }
}

void calc_force()
{
    int i = int(gl_WorkGroupID.x);
    int k = int(gl_LocalInvocationID.y);
    //int k = int(gl_WorkGroupID.y);
    int j = int(gl_LocalInvocationID.x);

    int kk = nn/32;

    for (int z = 0; z < kk; z++) {
        for (int y = 0; y < kk; y++) {
            for (int x = 0; x < kk; x++) {
                calc_force_(z*32+i, y*32+k, x*32+j);
            }
        }
    }
}

void main() {
    uint i,k,j;

    if (stage == 1 || stage == 0) {
        // 0. initial state
//        lists[i][j] = -1;
//        lists[i][k] = -1;

        int kk = nn/32;

        for (int y = 0; y < kk; y++) {
            for (int x = 0; x < kk; x++) {
                i = gl_LocalInvocationID.y;
                k = gl_LocalInvocationID.x;
                for (j = 0; j < nn; j++) {
                    cell_data[(off(y*32+i,x*32+k,j))*cell_size] = 0;
                }
            }
        }

        barrier();
/*
        // 1. "sort" points
        uint threads = xsize*ysize*zsize;
        uint work_size = (particles + threads - 1) / threads;
        uint from = globalIndex * work_size;
        uint to = from+work_size;
        for (i = from; i < to && i < particles; i++) {
            list[i] = -1;
        }

        // lists by x,y
        for (i = from; i < to; i++) {
            if (i < particles) {
                vec2 x = vec2(Position[i])-vec2(origin);
                ivec2 index = ivec2(floor(x/h));
                int j = int(i);

                list[j] = atomicExchange(lists[index.y][index.x], j);
            }
        }

        barrier();
*/
        // each thread works with own list[y][x]
        int cur = list[particles+gl_LocalInvocationID.y*32+gl_LocalInvocationID.x];

        //int cur = lists[gl_LocalInvocationID.y][gl_LocalInvocationID.x];
        while (cur != -1) {
            vec3 x = vec3(Position[cur]) - vec3(origin);
            ivec3 index = ivec3(floor(x/h));
            int cell_id = off(index.z,index.y,index.x);
            uint n = cell_data[cell_id*cell_size];
            if (n < max_per_cell) {
                cell_data[cell_id*cell_size+n+1] = cur;
                cell_data[cell_id*cell_size] = n+1;
            }

            cur = list[cur];
        }

        // 2. use sorted
        barrier();
    }

    if (stage == 0) {
        calc_force_single();
    } else if (stage == 2) {
        calc_force();
        //calc_force_single();
    }
}
